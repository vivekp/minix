diff -ru nbsdsrc/src/usr.bin/su/Makefile usr.bin/su/Makefile
--- nbsdsrc/src/usr.bin/su/Makefile
+++ usr.bin/su/Makefile
@@ -3,6 +3,12 @@
 
 .include <bsd.own.mk>
 
+.if defined(__MINIX)
+USE_PAM=no
+USE_KERBEROS=no
+USE_SKEY=no
+.endif
+
 USE_FORT?= yes	# setuid
 PROG=	su
 BINOWN=	root
@@ -10,8 +16,10 @@
 
 .PATH.c: ${.CURDIR}/../newgrp
 CPPFLAGS+=-I${.CURDIR}/../newgrp
+.if !defined(__MINIX)
 CPPFLAGS+=-DLOGIN_CAP
 CPPFLAGS+=-DALLOW_GROUP_CHANGE
+.endif
 CPPFLAGS+=-DALLOW_EMPTY_USER
 CPPFLAGS+=-DGRUTIL_SETGROUPS_MAKESPACE
 
diff -ru nbsdsrc/src/usr.bin/su/su.c usr.bin/su/su.c
--- nbsdsrc/src/usr.bin/su/su.c
+++ usr.bin/su/su.c
@@ -85,8 +85,12 @@
 #endif
 
 #ifndef	SU_GROUP
+#ifdef __minix
+#define	SU_GROUP	"operator"
+#else
 #define	SU_GROUP	"wheel"
 #endif
+#endif
 
 #define GROUP_PASSWORD	"Group Password:"
 
@@ -96,6 +100,7 @@
 #define ARGSTR ARGSTRX
 #endif
 
+void add2env(char **, char *, int);
 static int check_ingroup(int, const char *, const char *, int);
 
 int
@@ -347,6 +352,68 @@
 		err(EXIT_FAILURE, "setuid");
 #endif
 
+#ifdef __minix
+#define EXTRA_ENV 6
+
+	char **env;
+	int ap, envsiz;
+	char path[1024];
+	char usern[32];
+	char logname[35];
+	char home[128];
+	char usershell[128];
+	char terminal[128];
+	char su_from[128];
+
+	char *bp, *sh, *argx[8], **ep;
+	char argx0[64];
+
+	/* Create the argv[] array from the pw_shell field. */
+	ap = 0;
+	argx[ap++] = argx0;
+	if (pwd->pw_shell[0]) {
+		sh = pwd->pw_shell;
+		bp = sh;
+		while (*bp) {
+			while (*bp && *bp != ' ' && *bp != '\t') bp++;
+			if (*bp == ' ' || *bp == '\t') {
+				*bp++ = '\0';	/* mark end of string */
+				argx[ap++] = bp;
+			}
+		}
+	} else
+	argx[ap] = NULL;
+	strcpy(argx0, "-");	/* most shells need it for their .profile */
+	if ((bp= strrchr(sh, '/')) == NULL) bp = sh; else bp++;
+	strncat(argx0, bp, sizeof(argx0) - 2);
+
+	/* Set the environment */
+	if (asme && !asthem) {
+		for (ep = environ; *ep; ep++)
+			;
+	} else
+		ep = environ;
+
+	envsiz= ep-environ;
+	env= calloc(envsiz + EXTRA_ENV, sizeof(*env));
+	if (env == NULL)
+	{
+		fprintf(stderr, "login: out of memory\n");
+		exit(1);
+	}
+	int i;
+	for (i= 0; i<envsiz; i++)
+		env[i]= environ[i];
+
+	/* PATH should be set according to the '-m' flag.
+	 * This is a temporary hack to set PATH without '-m' flag,
+	 * and must be fixed later. 
+	 */ 
+	strcpy(path, "PATH=");
+	strcat(path, _PATH_DEFPATH);
+	add2env(env, path, 1);
+#endif
+	
 	if (!asme) {
 		if (asthem) {
 			p = getenv("TERM");
@@ -358,23 +425,54 @@
 				LOGIN_SETPATH) == -1)
 				err(EXIT_FAILURE, "setting user context");
 #else
+#ifndef __minix
 			(void)setenv("PATH", _PATH_DEFPATH, 1);
-#endif
+#endif /* __minix */
+#endif /* LOGIN_CAP */
 			if (p)
+#ifndef __minix
 				(void)setenv("TERM", p, 1);
+#else
+				strcpy(terminal, "TERM=");
+				strcat(terminal, p);
+				add2env(env, terminal, 1);
+#endif /* __minix */	
 			if (gohome && chdir(pwd->pw_dir) == -1)
 				errx(EXIT_FAILURE, "no directory");
 		}
 
 		if (asthem || pwd->pw_uid) {
+#ifndef __minix
 			(void)setenv("LOGNAME", pwd->pw_name, 1);
 			(void)setenv("USER", pwd->pw_name, 1);
+#else
+			strcpy(logname, "LOGNAME=");
+			strcat(logname, pwd->pw_name);
+			add2env(env, logname, 1);
+			strcpy(usern, "USER=");
+			strcat(usern, pwd->pw_name);
+			add2env(env, usern, 1);
+#endif /* __minix */	
 		}
+#ifndef __minix
 		(void)setenv("HOME", pwd->pw_dir, 1);
 		(void)setenv("SHELL", shell, 1);
+#else
+		strcpy(home, "HOME=");
+		strcat(home, pwd->pw_dir);
+		add2env(env, home, 1);
+		strcpy(usershell, "SHELL=");
+		strcat(usershell, pwd->pw_shell);
+		add2env(env, usershell, 1);
+#endif
 	}
+#ifndef __minix
 	(void)setenv("SU_FROM", username, 1);
-
+#else
+	strcpy(su_from, "SU_FROM=");
+	strcat(su_from, username);
+	add2env(env, su_from, 1);
+#endif
 	if (iscsh == YES) {
 		if (fastlogin)
 			*np-- = __UNCONST("-f");
@@ -429,7 +527,11 @@
 	/* Raise our priority back to what we had before */
 	(void)setpriority(PRIO_PROCESS, 0, prio);
 
+#ifdef __minix
+	execve(shell, argx, env);
+#else
 	(void)execv(shell, np);
+#endif
 	err(EXIT_FAILURE, "%s", shell);
 	/* NOTREACHED */
 }
@@ -583,3 +685,26 @@
 #endif
 	return ok;
 }
+
+#ifdef __minix
+void add2env(char **env, char *entry, int replace)
+{
+/* Replace an environment variable with entry or add entry if the environment
+ * variable doesn't exit yet. 
+ */
+	char *cp;
+	int keylen;
+
+	cp= strchr(entry, '=');
+	keylen= cp-entry+1;
+
+	for(; *env; env++)
+	{
+		if (strncmp(*env, entry, keylen) == 0) {
+			if (!replace) return;		/* Don't replace */
+			break;
+		}
+	}
+	*env= entry;
+}
+#endif
